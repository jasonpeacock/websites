<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="generator" content="pandoc">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                        <meta name="dcterms.date" content="2019-01-13">
                        <title>Small Changes</title>
        <style type="text/css">code{white-space: pre;}</style>
                                <link rel="stylesheet" href="/css/footer.css">
                <link rel="stylesheet" href="/css/pandoc-solarized.css">
                <link rel="stylesheet" href="/css/pandoc.css">
                <link rel="stylesheet" href="/css/tufte-extra.css">
                <link rel="stylesheet" href="/css/tufte.css">
                        <!--[if lt IE 9]>
            <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
        <![endif]-->
            </head>
    <body>
                <article>
                        <header>
                <h1 class="title">Small Changes</h1>
                                <p class="subtitle">How do your features grow?</p>
                                                <p class="byline">January 13, 2019</p>
                            </header>
                                                <nav id="TOC">
                <h2 class="toc">Table Of Contents</h2>
                <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#what-usually-happens">What Usually Happens</a></li>
                <li><a href="#what-went-wrong">What Went Wrong</a></li>
                <li><a href="#making-small-changes">Making Small Changes</a><ul>
                <li><a href="#the-importance-of-definition-of-done">The importance of Definition of Done</a></li>
                </ul></li>
                <li><a href="#small-changes-in-practice">Small Changes in Practice</a><ul>
                <li><a href="#every-story-has-day-sized-tasks">Every story has day-sized tasks</a></li>
                </ul></li>
                <li><a href="#adopting-small-changes">Adopting Small Changes</a></li>
                <li><a href="#benefits-of-small-changes">Benefits of Small Changes</a></li>
                <li><a href="#faq">FAQ</a><ul>
                <li><a href="#changes-cant-be-completed-in-a-day.">Changes can’t be completed in a day.</a></li>
                <li><a href="#code-reviews-dont-happen-fast-enough-to-release-every-day.">Code reviews don’t happen fast enough to release every day.</a></li>
                <li><a href="#our-release-process-doesnt-support-changes-every-day.">Our release process doesn’t support changes every day.</a></li>
                <li><a href="#when-is-a-small-change-too-small">When is a small change too small?</a></li>
                <li><a href="#how-does-this-fit-with-agile-development">How does this fit with Agile Development?</a></li>
                <li><a href="#how-do-i-know-what-changes-are-needed-before-i-start">How do I know what changes are needed before I start?</a></li>
                <li><a href="#how-do-you-revert-the-feature-without-a-single-atomic-commit">How do you revert the feature without a single, atomic commit?</a></li>
                <li><a href="#how-to-work-on-serial-tasks-without-being-blocked-by-reviews">How to work on serial tasks without being blocked by reviews?</a></li>
                </ul></li>
                </ul>
            </nav>
                                    <section id="introduction" class="level2">
<h2>Introduction</h2>
<p><span class="newthought">Many teams have fallen</span> into a <em>mini-waterfall</em> process. They call it <em>Agile Development</em> because they are squeezing a feature’s full lifecycle<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Design, implementation, testing, review, documentation, release.<br />
<br />
</span></span> into a single sprint, but they are not reaping the benefits.</p>
<p>For small features, this is not a problem, but most features are not small. Features sound small when first captured as a user story; once development starts there is refactoring, code cleanup, unit &amp; integration tests, code review (with revisions!), and documentation before it can be released.</p>
<p>Making small changes puts the <em>agile</em> back in Agile Development.</p>
</section>
<section id="what-usually-happens" class="level2">
<h2>What Usually Happens</h2>
<p><span class="newthought">Your team is starting</span> its next sprint<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">It doesn’t matter how long your sprint is – 2wks, 4wks – the story is always the same.<br />
<br />
</span></span>. You’re excited to deliver a long-anticipated feature, and customers are excited to see the feature finally assigned to a sprint and moved to <em>Work In Progress</em> status.</p>
<p>Each day during stand-up you report that you’re making good progress and there are no blockers. It’s taking a little more effort than planned because you had to refactor some shared logic, and update a dependency which had a new API. But you’re still confident the feature will be completed by the end of the sprint.</p>
<p>As the sprint draws to a close you complete your work on the feature; it works exactly as described in the user story. You’re ready for the sprint demo and excited to show customers.</p>
<p>You send the code review to your teammates. You didn’t have time to write tests because of the refactoring work and dependency upgrade, but you filed a backlog item to add tests later, so it’s OK.</p>
<p>Late in the day you finally get some feedback on your code review. It’s good feedback, but some of the feedback changes are not trivial. You realize that it’s going to be a long night to make most of the feedback changes in time for the sprint demo.</p>
<p>You won’t have time to update the documentation, and you’ll have to move some of the larger feedback changes to the backlog as follow-up issues, but at the feature will be released!</p>
<p>Hopefully there is no additional feedback when you update the code review…</p>
<p>Best case: you released the feature to customers on time and created new technical debt:</p>
<ul>
<li>No tests.</li>
<li>No documentation.</li>
<li>Open issues from the code review.</li>
</ul>
<p><span class="newthought">Or maybe</span> your team has a <em>Definition of Done</em><span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Coded, reviewed, tested, documented, and released.<br />
<br />
</span></span>, and you can’t release the feature without testing and documentation. Even though the feature is code-complete, it’s not <em>done</em>.</p>
<p>You failed to release the feature; it goes back into the backlog to be re-prioritized for the next sprint. If you’re lucky, you’ll continue working on it in the next sprint and hopefully release it then. If not, the feature slowly rots on its own branch and will require extra work to bring it back up-to-date<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote"><code>git rebase</code>, etc.<br />
<br />
</span></span> before it can be completed.</p>
</section>
<section id="what-went-wrong" class="level2">
<h2>What Went Wrong</h2>
<p><span class="newthought">Every sprint</span> starts with the best intentions.</p>
<p>The feature was developed in isolation<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">Usually on a feature branch.<br />
<br />
</span></span> and prepared for a big bang<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="sidenote">One moment the feature is not there, then <strong>BANG!</strong> it’s there.<br />
<br />
</span></span> release. After approval the changes were merged to <code>master</code> and released.</p>
<p>The problem was spending 90% of the sprint on one part of the feature lifecycle – implementation – while skipping the design phase and leaving little time for testing, review, documentation, and release.</p>
<p>The result is a rush to release the feature before the sprint ends, with a lot of pressure on teammates to approve the changes, deferring any significant feedback and accepting technical debt, all in the name of completing the story on time<span><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle"/><span class="sidenote">Also known as <em>Date-Driven Development</em>, where changes are released by deadline (e.g. end of sprint) instead of when they meet the Definition of Done.<br />
<br />
</span></span>.</p>
</section>
<section id="making-small-changes" class="level2">
<h2>Making Small Changes</h2>
<p><span class="newthought">Aim for a steady trickle</span> of small changes released throughout the sprint instead of a big-bang release at the end of the sprint.</p>
<p>A small change is the smallest step<span><label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle"/><span class="sidenote">A small change should make sense on its own, don’t break a change in half just to make it small. Figure out the steps to implementation the change, then make each step a small change.<br />
<br />
</span></span> that moves the feature closer to complete. Small changes usually align with the implementation steps in the feature design.</p>
<p>Small changes don’t always result in a customer-visible change, they can refactor existing code or lay the groundwork for later changes.</p>
<p>Small changes are released as they are completed, which includes review, testing, and documentation to meet the <em>Definition of Done</em>.</p>
<p>The work of coding, testing, reviewing, documenting, and releasing a change should all be <em>completed within one business day</em><span><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle"/><span class="sidenote">It doesn’t have to be literally 8am to 5pm, it could be 10am today to 10am tomorrow, etc. A casual approach could be “make a change today, release it tomorrow morning, then start the next change.”<br />
<br />
</span></span>. If it takes two days, or a week, to complete a change then it isn’t small.</p>
<p>Completing small changes within a day is possible because small changes have small tests, quick reviews, short docs, and fast releases.</p>
<p>Frequently, small changes are completed in less than a day, and multiple changes are released in the same day.<span><label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle"/><span class="sidenote">This is a good goal to strive for, it demonstrates you have achieved small-change enlightenment!<br />
<br />
</span></span></p>
<section id="the-importance-of-definition-of-done" class="level3">
<h3>The importance of Definition of Done</h3>
<p>Making small changes is not about pushing whatever the current state of the feature is at the end of the day.</p>
<p>Commonly, a series of changes are released to support a feature, then another series of changes are released to pay off the technical debt (code cleanup, refactoring, unit tests).</p>
<p>That’s just making changes to production “live”, accumulating technical debt to be paid off before the feature can be completed.</p>
<p>Applying the <em>Definition of Done</em> to every change ensures no technical debt is accumulated. Feature development can be stopped<span><label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle"/><span class="sidenote">Priorities change, fires need fighting, orgs get re-org’d.<br />
<br />
</span></span> at any moment with no technical debt.</p>
</section>
</section>
<section id="small-changes-in-practice" class="level2">
<h2>Small Changes in Practice</h2>
<p><span class="newthought">At the start of each sprint</span> every story is broken down into day-sized tasks (or smaller) needed to implement the features.</p>
<p>This is a great opportunity for a sanity check - can all the tasks for each story be completed in the current sprint? Some stories may need to be split into additional backlog stories if there are too many tasks.</p>
<p>Each day, developers make code changes, write tests, and do code reviews. They update docs and release small changes, completing the tasks.</p>
<p>When developers are waiting on code review feedback for a task they can switch<span><label for="sn-12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-12" class="margin-toggle"/><span class="sidenote">Multitasking has been proven to not work. Instead, this follows the single-tasking approach of working one thing until blocked, <em>then</em> switching.<br />
<br />
</span></span> to another task and start working on that small change.</p>
<section id="every-story-has-day-sized-tasks" class="level3">
<h3>Every story has day-sized tasks</h3>
<p>Some stories are simple and only need one task. A day-sized task is still created to track the effort.</p>
<p>Some stories have tasks that are not development related – debugging, doc writing, design, training, etc. They are still broken down into day-sized tasks.</p>
<p>Open-ended tasks such as investigation or debugging are broken down into day-sized tasks with goals for each day, even when the effort spans multiple days.</p>
<p>Creating day-sized tasks for all efforts, even on-going multi-day efforts, ensures the team always knows the current status of all stories and avoids the useless “it’s still in progress” daily stand-up update.</p>
</section>
</section>
<section id="adopting-small-changes" class="level2">
<h2>Adopting Small Changes</h2>
<p><span class="newthought">It can be challenging</span> to adopt new practices like making small changes. Here are some suggestions to apply in your team:</p>
<ul>
<li>Schedule a daily time for teammates to review open CRs to unblock small changes.</li>
<li>Create tasks *smaller** than a day, as they will most likely be under-estimated.</li>
<li>Break down stories into tasks as a team.</li>
<li>Update tasks every day, don’t wait until the end of the sprint.</li>
</ul>
</section>
<section id="benefits-of-small-changes" class="level2">
<h2>Benefits of Small Changes</h2>
<p>✓ <em>Easy to understand</em></p>
<p>Small changes are easy to understand and quick to communicate to all teammates, instead of the one teammate who did the review.<span><label for="sn-13" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-13" class="margin-toggle"/><span class="marginnote"> Big changes can require sitting with teammates to explain them, or even a team meeting!<br />
<br />
</span></span></p>
<p>✓ <em>Fast code reviews</em></p>
<p>Small changes have small code reviews, and fast turnaround, increasing the chance of multiple teammates participating in the review.<span><label for="sn-14" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-14" class="margin-toggle"/><span class="marginnote"> Big changes require playing tag to find a teammate for your review, because nobody wants spend their time on a large review. Large reviews produce lots of feedback, which leads to many revisions.<br />
<br />
</span></span></p>
<p>✓ <em>Continuous feedback</em></p>
<p>Teammates can provide early &amp; constant feedback when releasing small changes frequently. It’s cheaper to change your implementation early, before you are fully invested, and when you are more receptive to feedback.</p>
<p>Feedback about performance, bugs, etc. is immediate when small changes are released frequently.</p>
<p>✓ <em>Code is always working</em></p>
<p>Code is always in a working state when releasing small changes, you avoid “tear it all apart and try to put it back together” problems.</p>
<p>✓ <em>Test coverage is clear</em></p>
<p>Writing comprehensive tests cases is straightforward when changes are small; reviewers understand what changed and what should be included in testing.</p>
<p>✓ <em>Documentation is updated continuously</em></p>
<p>Writing documentation can be slow and overwhelming, small changes minimize the required documentation.</p>
<p>✓ <em>Bugs are smaller</em></p>
<p>Bugs are easier to find; <code>git-bisect</code> works very well when a feature is composed of many small changes. You can pinpoint the exact (small!) change that caused the issue instead of debugging a large change in a single commit.</p>
<p>✓ <em>High confidence releases</em></p>
<p>It’s easier to capture and understand the impact of small changes,</p>
<p>✓ <em>Work can be paused at any time.</em></p>
<p>The amount of in-progress work is small when all changes are small and already released. If priorities change, all the work for the feature is either already released as small changes or not yet started, and it can easily be moved to the backlog to be resumed later.</p>
<p>✓ <em>No merge hell.</em></p>
<p>Small changes have small scope, and rarely conflict with changes from other teammates. Small changes are easy to rebase before you release, and just as easy for your teammates to rebase after release.</p>
<p>✓ <em>Progress is obvious.</em></p>
<p>Burn down graphs and other tracking tools provide fine-grained detail due to small changes being constantly released &amp; their tasks resolved. Teammates, managers, and customers how close the feature is being completed, and can easily track the team’s progress towards its sprint goals.</p>
</section>
<section id="faq" class="level2">
<h2>FAQ</h2>
<section id="changes-cant-be-completed-in-a-day." class="level3">
<h3>Changes can’t be completed in a day.</h3>
<p>The team’s <em>Definition of Done</em> may be too onerous. Review the definitions to see what is causing the most friction. It does not need to be extensive – usually it is as simple as “code complete, tested, and reviewed.” Many teams include documentation and release as well.</p>
<p>Or, the tasks are not actually day-sized. Teams are usually optimistic, especially when they are not used to including testing, review, and release in their task estimates. Try breaking down the tasks into smaller than day-sized estimates until the team</p>
</section>
<section id="code-reviews-dont-happen-fast-enough-to-release-every-day." class="level3">
<h3>Code reviews don’t happen fast enough to release every day.</h3>
<p>Schedule a daily time for teammates to review open CRs to unblock small changes, or have assigned teammates responsible for handling CRs each day.</p>
</section>
<section id="our-release-process-doesnt-support-changes-every-day." class="level3">
<h3>Our release process doesn’t support changes every day.</h3>
<p>Small changes and agile development go hand-in-hand with continuous development. Teams can use the frequent releases of small changes to work on improving their continuous development expereince and streamline the release process.</p>
</section>
<section id="when-is-a-small-change-too-small" class="level3">
<h3>When is a small change too small?</h3>
<p>There is an overhead to applying the <em>Definition of Done</em> to too-small changes, just as there is an exponential cost with changes that are too large.</p>
<p>Don’t release changes just for the sake of releasing every day. Evaluate if the change moves the feature closer to complete.</p>
</section>
<section id="how-does-this-fit-with-agile-development" class="level3">
<h3>How does this fit with Agile Development?</h3>
<p>kent beck’s “commit or revert” experiment</p>
<p>https://medium.com/<span class="citation" data-cites="kentbeck_7670/limbo-on-the-cheap-e4cfae840330">@kentbeck_7670/limbo-on-the-cheap-e4cfae840330</span></p>
<p>https://medium.com/<span class="citation" data-cites="kentbeck_7670/test-commit-revert-870bbd756864">@kentbeck_7670/test-commit-revert-870bbd756864</span></p>
<p>don’t take my work for it: https://en.wikipedia.org/wiki/Kent_Beck</p>
</section>
<section id="how-do-i-know-what-changes-are-needed-before-i-start" class="level3">
<h3>How do I know what changes are needed before I start?</h3>
<p>This is what skipping the design phase sounds like. Before making any changes there should be a design, reviewed with your teammates, about how the feature will be implemented.</p>
<p>Depending on the size of the feature, the design can be:</p>
<ol type="1">
<li>A bullet list of exit criteria in the story description, as the changes are obvious &amp; straightforward.</li>
<li>A quick 2-4 paragraphs in a wiki describing the problem to be solved and the changes required to solve it.</li>
<li>A full design document, capturing the problems, customer requirements, user experience, and proposed solution/implementation.</li>
</ol>
<p>Of course, nothing says that you’re not allowed to change your mind. Was that change 3 commits ago not quite right? Change it!</p>
</section>
<section id="how-do-you-revert-the-feature-without-a-single-atomic-commit" class="level3">
<h3>How do you revert the feature without a single, atomic commit?</h3>
<p>Use feature flags.</p>
<p>Changes are released continually and bugs fixed as they appear, less risk than big-bang release.</p>
<p>Use <code>git-bisect</code> to identify the commit that introduced the change, can’t do that with big-bang release.</p>
</section>
<section id="how-to-work-on-serial-tasks-without-being-blocked-by-reviews" class="level3">
<h3>How to work on serial tasks without being blocked by reviews?</h3>
<p>Use <code>git</code> branches.</p>
</section>
</section>
        </article>
                <footer>
            Copyright&nbsp;&copy;&nbsp;2016&#8209;2019&nbsp;Jason&nbsp;Peacock All&nbsp;Rights&nbsp;Reserved. Comments?&nbsp;Email&nbsp;me:&nbsp;<a href="mailto:jason@jasonpeacock.com">jason@jasonpeacock.com</a>
        </footer>
    </body>
</html>
